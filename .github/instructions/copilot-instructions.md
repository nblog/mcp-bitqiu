## 🎯 核心协作原则

### 1. 需求澄清优先
- **模糊问题时，多提问而非急于解决**
- 通过**递增式明确目标**，逐步细化需求
- 双方达成一致建议后再开始实施
- 避免基于假设进行开发

### 2. 代码质量至上
- 发现更优雅的实现时，**必须主动提出**
- 支持为了提高可读性而进行重构
- 优先考虑代码的长期维护性
- 追求简洁、清晰、易懂的代码风格
- 遵循 **DRY** 原则，避免重复性维护

## 🏗️ 编程偏好与规范

### 数据结构与序列化
- **强烈偏好结构化数据定义**
  - 使用 `Pydantic` 等工具定义数据模型
  - 避免过度依赖字典的"记忆性"键值访问
  - 优先类型安全的序列化/反序列化方案

```python
# ✅ 推荐方式
from pydantic import BaseModel

class UserProfile(BaseModel):
    name: str
    age: int
    email: str

# ❌ 避免方式
user_data = {"name": "...", "age": "...", "email": "..."}
```

### 数据一致性与维护性
- **单一数据源原则**
  - 避免在多处硬编码相同的值或逻辑
  - 通过引用确保数据的一致性
  - 设计时考虑未来的扩展和修改

```python
# ✅ 推荐：数据定义与使用保持同步
from enum import Enum

class Status(Enum):
    ACTIVE = "active"
    INACTIVE = "inactive"

# 验证时直接引用枚举
if status not in [s.value for s in Status]:
    valid_statuses = ", ".join([s.value for s in Status])
    raise ValueError(f"状态必须是: {valid_statuses}")

# ❌ 避免：多处硬编码相同信息
# models.py
VALID_STATUSES = ["active", "inactive"]

# main.py
if status not in ["active", "inactive"]:  # 容易遗漏更新
    print("错误：状态必须是 active 或 inactive")
```

### 代码组织与架构
- 清晰的项目结构和模块划分
- 合理的抽象层次和职责分离
- 优先使用类型提示和文档字符串
- 遵循 SOLID 原则和设计模式
- 集中管理配置、常量、枚举等定义

### 错误处理与日志
- 明确的异常处理策略
- 结构化的日志记录
- 优雅的错误恢复机制

## 💬 沟通与协作风格

### 问题分析流程
1. **理解阶段**: 澄清需求和约束条件
2. **规划阶段**: 制定技术方案和实施计划
3. **确认阶段**: 双方达成一致后开始实施
4. **迭代阶段**: 根据反馈持续改进

### 建议提出方式
- 主动指出潜在的优化点
- 提供多种解决方案供选择
- 解释技术决策的利弊权衡
- 考虑未来扩展性和维护成本
- 发现重复性维护点时立即提出重构建议

## 🔧 技术栈偏好

### 开发工具
- **依赖管理**: uv

## 📋 代码审查清单

### 结构化数据
- [ ] 是否使用了类型安全的数据模型？
- [ ] 是否避免了过度使用字典存储结构化数据？
- [ ] 数据验证是否完整？
- [ ] 是否遵循了单一数据源原则？

### 代码质量
- [ ] 代码是否足够清晰易读？
- [ ] 是否存在更优雅的实现方式？
- [ ] 错误处理是否完善？
- [ ] 是否有适当的类型提示？
- [ ] 是否存在重复的硬编码值或逻辑？

### 维护性检查
- [ ] 修改枚举/常量时，是否需要同步更新多处代码？
- [ ] 验证逻辑是否直接引用了数据定义？
- [ ] 是否存在可以通过配置或引用统一管理的重复内容？

### 架构设计
- [ ] 模块职责是否清晰？
- [ ] 是否遵循了设计原则？
- [ ] 扩展性如何？
- [ ] 测试覆盖率是否足够？

---

## 📄 文档与 README 规范
- 项目必须包含一份 `README.md`（英文版）
- 并且同时维护一份 `README.zh-CN.md`（中文版），确保中英文说明内容保持同步
- 任何对 `README.md` 的更新，都应同步反映到 `README.zh-CN.md`

---

*本文档会根据项目进展和新的偏好持续更新*
